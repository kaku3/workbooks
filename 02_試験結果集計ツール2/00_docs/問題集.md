@import "./style.less"

# 試験結果集計ツール2


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [試験結果集計ツール2](#試験結果集計ツール2)
  - [はじめに](#はじめに)
  - [要素技術](#要素技術)
  - [機能追加(集計) : 1](#機能追加集計-1)
    - [設計コラム : 『集計時に』ついて](#設計コラム-集計時について)
    - [事前にあるとよさそうな知識](#事前にあるとよさそうな知識)
    - [解答例](#解答例)
      - [変更箇所の確認](#変更箇所の確認)
  - [機能追加(集計) : 2](#機能追加集計-2)
    - [設計コラム : 仕様変更](#設計コラム-仕様変更)
    - [解答例](#解答例-1)

<!-- /code_chunk_output -->


## はじめに

デイリーの集計が不要な小規模プロジェクトを考慮して、課題を分けました。

本課題の前に[試験結果集計ツール](../../01_%E8%A9%A6%E9%A8%93%E7%B5%90%E6%9E%9C%E9%9B%86%E8%A8%88%E3%83%84%E3%83%BC%E3%83%AB/00_docs/%E5%95%8F%E9%A1%8C%E9%9B%86.md)を実施しておいてください。

また、レポートを欲しがる上層部に http server を用意してくださいとは言えないので、実践的な html 版の課題が続きます。Nuxt.js 編の課題はもう少し後になります。


## 要素技術

- Node.js : 集計
- html, jQuery, DataTables : 表示
- chart.js : グラフ表示


## 機能追加(集計) : 1

Excel日付を表示用日付に変換して表示できるようにしたい。

集計ツールで出力されたデータの試験実施日を確認すると以下のような値であることが確認できる。

```
"testDate":44844
```

これは、シリアル値と呼ばれるマイクロソフト独自の日時表現形式で、1900年1月1日を1として、以後1日経過ごとに1を加えた数値である。
※1日未満は小数点で表現。

この値を表示しても試験実施日が読み取れないので、**集計時に**yyyy/mm/dd形式の値も保存する様に修正する。

```
"testDate":44844,
"displayTestDate":"2022/10/10"  // ★追加
```

また、Excel日付→日付変換ロジックは汎用的に使える様に別のクラスで実装しておく。


### 設計コラム : 『集計時に』ついて

シリアル値→日付変換は、計算で求まる値であるため集計時に保持する必要はない。
クライアント側で表示する時に計算で求めればデータを保持する量が少なくなるためDBやストレージには優しい。

ところが今回は、クライアント側を2種類(jQuery版、nuxt版)作成する計画がある。とした場合、それぞれのクライアントに対して日付変換処理を実装するよりは集計処理側に実装する方がコスパがよいと考えられる。

また、冒頭で述べた様に、このツールで出力される**レポートを閲覧するユーザーがサーバを用意できないといった条件がある場合**、実装者にとってはNuxt.jsやNext.jsで製造する方が簡単でも、それらのフレームワークを選択することはできなくなる。[^1]

このように、**最適な設計はシステムを取り巻く条件や環境**によって変わってくる。「なぜその設計にするのか」「メリット」「デメリット」などは常に考える様にしておくとよいでしょう。


### 事前にあるとよさそうな知識

- シリアル値
1900年1月1日から経過日数。

- [UNIX時間](https://ja.wikipedia.org/wiki/UNIX%E6%99%82%E9%96%93)
協定世界時 (UTC) での1970年1月1日午前0時0分0秒（UNIXエポック）から形式的な経過秒数。


### 解答例

[01_解答例_追加仕様_集計_1](../10_src/01_%E8%A7%A3%E7%AD%94%E4%BE%8B_%E8%BF%BD%E5%8A%A0%E4%BB%95%E6%A7%98_%E9%9B%86%E8%A8%88_1/convert.js)

#### 変更箇所の確認

今回の課題では既存ソースに対する修正を行った。変更箇所を確認するには、主に以下３通りの方法がある。現場によって使えるツールに制限があるが、新しくて簡単な方法をチェックする習慣は持っておいた方がいいだろう。

1. VS Code のタイムラインビューで確認
該当のコミットでの変更を確認できる。通常の開発で修正されたコードを確認するのであればこれを用いるのがよいと思う。

@import "./images/timeline-view.png"


また、Git管理下のファイルを確認するのであれば以下も併用したい。

- [GitHistory](https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory)
- [GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens)

@import "./images/gitlens-githistory.png"

2. [Partial Diff](https://marketplace.visualstudio.com/items?itemName=ryu1kn.partial-diff) で確認
VS Code プラグインを追加し、変更元ソースと比較する。

3. [WinMerge](https://winmerge.org/?lang=ja) で確認
昭和から脈々と利用され続けているイニシエのツールを用いて比較する。


## 機能追加(集計) : 2

試験管理を行う上での重要指標には、日ごとの試験消化件数と、人ごとの試験消化件数がある。
現仕様では、Excel ファイル単位でその内容を json 化したデータを出力しているが、それと合わせて日ごとの試験消化件数と、人ごとの試験消化件数を出力する。

```js

// 仕様変更前
[
  { excel1 の内容..., excel1 の集計 },
  { excel2 の内容..., excel2 の集計 },
  ...
]
```
```js
// 仕様変更後
{
  testFiles: [
    { excel1 の内容..., excel1 の集計 },
    { excel2 の内容..., excel2 の集計 },
    ...
  ],
  dates: [
    { 日1 の集計 }, // 日1 に対する、人毎の消化数とその合計
    { 日2 の集計 }, // 日2 に対する、人毎の消化数とその合計
    ...
  ],
  testers: [
    { tester1 の集計 }, // tester1 に対する、日毎の消化数とその合計
    { tester2 の集計 }, // tester2 に対する、日毎の消化数とその合計
    ...
  ]
}
```


- 日ごとの消化件数

例えば、1000件の試験を消化するのに1日30件消化、バッファ込みでおよそ40営業日という試験計画があるとする。ここで、消化実績が1日10件なのか、50件なのかを知ることで計画の修正が必要かを検討することができる。

マトリックス試験や、大量にデータ準備が必要な試験など、実施が非常に大変な試験もあるため、単純に進捗が悪い日が一日あったからと言って計画に問題があるとは判断できない。バーンダウンチャートなどを使って推移を見れるようにするのが望ましい。

- 人ごとの消化件数

一人の人間が一日にどの様な試験を何件ぐらい消化できるのかを知ることは、次回試験で妥当な計画を立てる指標となる。新人とベテランなどで消化件数には個人差が出る。


### 設計コラム : 仕様変更

今回は開発内容に対して、大きな仕様変更が発生した。

日毎の集計結果は、毎日ツールを動かしていれば、手元に残っているはずなので作らなくてもよいと言えばよい。
深刻なプロジェクトであれば、当然毎日ツールを動かして集計結果を確認しているだろうし、そのデータを何かにコピペしてバーンダウンチャートを作成することは可能なはずとゴネることもできるだろう。
ただ残念なことに、深刻なプロジェクトでは往々にしてプロジェクト管理のための時間確保ができない。コマンドひとつで進捗の集計がされグラフが出力されないのであれば、バーンダウンチャートを作成することもなく、霧の中を進む様な試験管理を続けることになるだろう。

このツールは、試験結果を集計するツールであるが、『試験管理を簡単にできるようにするため』のツールである。試験管理を簡単にできないのであれば、存在意義はない。

そのことを最初から念頭に置いて開発を進めると、仕様変更に対して「なんだよ最初から言えよ」といったヘイトをためないで済む。目の前の仕様をただ実装するのではなく、顧客のゴールから逆算して仕様が追加されても影響範囲が小さく済む様な実装をするのが望ましい。


### 解答例

[02_解答例_追加仕様_集計_2](../10_src/02_%E8%A7%A3%E7%AD%94%E4%BE%8B_%E8%BF%BD%E5%8A%A0%E4%BB%95%E6%A7%98_%E9%9B%86%E8%A8%88_2/convert.js)




[^1]: どんなにプログラム的に最適で美しくても、ユーザーが使えないのであればそれはただのプログラムでありプロダクトではない。お金になるのはプログラムではなくプロダクト。


## 機能追加(UI) : 1

### 1-1. テーブル表示
`機能追加(集計) : 2`で作成した json を、日毎、人毎の集計結果を以下の様に表示する。
見た目の調整は、tailwindcss、scss で行うこと。

@import "./images/日別・人別集計.png"

### 実装コラム : [tailwindcss](https://tailwindcss.com/)

ヘルパークラス群。`html`が汚れがちだが、`html` 以外汚れない、修正時の影響範囲が見えるのは精神衛生上よい。
web component と相性がよさそう。

### 1-2. グラフ表示

`機能追加(集計) : 2`で作成した json を、以下の様にグラフ表示する。
作業時は、以下キーワードでググるとよい。

- キーワード
  - バーンダウンチャート
  - [Chart.js](https://www.chartjs.org/)


### 実装コラム : 試験データ

この規模の実装課題では、実装より試験データの作成が大変である。
json を直接作成して試験データを作ってもよいが、解析ツールのデバッグも兼ねて、試験項目書のエクセルにダミー試験項目および試験結果を追加するのがよさそう。
1日何件程度試験を消化できるのが妥当か、開発規模ごとでどの程度の試験項目があるのが妥当か、を想像しながらデータを作るとよい。

Excel(Spread Sheet)には便利な関数や機能がたくさんあるので使いこなせるようになっておくとよい。
