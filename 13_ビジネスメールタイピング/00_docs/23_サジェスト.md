# サジェスト（試行錯誤レポート）

## 初期問題認識

次にタイプするキーをサジェストしたいが以下挙動により難しい。

- 出力は日本語
  - ひらがなからローマ字変換ならテーブル対応できるが漢字までは無理
- ローマ字のゆれ
  - 同じ「ち」を打つにも[ti][chi]など複数の打ち方がある
- IMEによる入力
  - 物理キー入力履歴と入力確定が一致しない

## 問題の具体化

### 1. 行進行問題
- 1行目のヒント機能は動作
- 2行目以降で機能しない（「2行目以降がうまく動かないみたいです」）

### 2. IME入力とバックスペースの同期問題
- 漢字表示「文言」をバックスペース1回削除
- ひらがな入力「もんごん」をバックスペース1回削除
- 上記2つの状態が異なるため、履歴同期が困難

### 3. DOM解析の限界
- 表示される漢字からローマ字パターンを逆算不可能
- イベント駆動アプローチの限界

## 解決アプローチの変遷

### Phase 1: イベント駆動アプローチ
- キーボードイベントとIME compositionイベントの組み合わせ
- 問題：複雑なIME状態管理が困難

### Phase 2: リアルタイム同期アプローチ
- textarea内容 + IME compositionText の直接解析
- DOMイベントに依存しない状態復元
- 実装：`syncWithRealTimeState()` メソッド

```javascript
// textarea内容とIME状態を直接解析
const textareaContent = this.textarea.value;
const imeContent = this.lastCompositionText || '';
const finalContent = textareaContent + imeContent;
```

### Phase 3: データ構造の根本的見直し

#### 問題の核心発見
漢字1文字に対して、複数のひらがなが対応することの理解：
- 「連」→「れん」（ひらがな2文字）
- 表示上は1文字だが、入力は複数のローマ字パターンが必要

#### 解決策：2次元配列構造
```javascript
// 従来（1次元・組み合わせパターン）
["re_n", "re_nn"]

// 新構造（2次元・ひらがな単位）
[["re"], ["n", "nn"]]
```

## 最終実装

### データ構造
```javascript
// hints.js
[ // ご連絡いただき
  [["go"]], // ご
  [["re"], ["n"]], // 連（れ＋ん）
  [["ra"], ["ku"]], // 絡（ら＋く）
  [["i"]], [["ta"]], [["da"]], [["ki"]] // いただき
]
```

### パターン選択ロジック
```javascript
// key-history-manager.js
getCurrentKanaPatterns() {
    // 現在のhistoryの長さに基づいて適切なひらがなパターンを選択
    let currentPatternIndex = 0;
    let accumulatedLength = 0;
    
    for (let i = 0; i < result.length; i++) {
        const patternLength = result[i][0].length;
        if (accumulatedLength + patternLength > this.history.length) {
            currentPatternIndex = i;
            break;
        }
        accumulatedLength += patternLength;
    }
    
    return result[currentPatternIndex];
}
```

### リアルタイム同期
```javascript
syncWithRealTimeState() {
    // textarea + IME状態を直接解析
    const finalContent = textareaContent + imeContent;
    
    // 行とカーソル位置を特定
    const lines = finalContent.split('\n');
    const currentLineIndex = lines.length - 1;
    const currentLineText = lines[currentLineIndex];
    
    // 漢字単位での進行状況を計算
    // ひらがなパターンとの照合で部分入力を復元
}
```

## 技術的洞察

### 1. 状態管理パラダイム
- **イベント駆動** → **状態復元駆動**
- キーイベントの追跡よりも、現在状態の解析を重視

### 2. データ構造設計
- **結合パターン** → **分離パターン**
- 漢字1文字 = ひらがな複数文字の原則を構造に反映

### 3. IME統合
- compositionイベントとtextarea内容の統合解析
- 確定テキストと変換中テキストの分離管理

## IME変換中の全角文字処理問題と解決策

### 問題の詳細
- **入力：「い」** → サジェスト：`t` ✅（動作中）
- **入力：「いｔ」** → サジェスト：`s` ❌（動作していない）

### 原因
1. IME変換中に全角の「ｔ」が`.incorrect`クラスの要素として表示される
2. 従来の処理では、IME変換中であっても`.incorrect`要素の内容を適切に解析していない
3. 全角→半角変換が不完全

### 解決アプローチ

#### 1. 全角文字の正規化処理
```javascript
normalizeCompositionText(text) {
    // 全角英数字を半角に変換
    let normalized = text.replace(/[Ａ-Ｚａ-ｚ０-９]/g, function(s) {
        return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
    });
    
    // ローマ字入力で使用される文字のみを残す
    normalized = normalized.replace(/[^a-zA-Z0-9あ-ん]/g, '');
    return normalized;
}
```

#### 2. IME変換中の`.incorrect`要素解析
```javascript
// IME変換中の場合、incorrect要素が全角文字を含んでいる可能性があるので
// この状態を解析してサジェストを提供する
if (incorrectElements.length > 0) {
    const incorrectText = Array.from(incorrectElements)
        .map(el => el.textContent).join('');
    
    // 全角文字を含むincorrect状態からの予測を試行
    const normalizedIncorrect = this.normalizeCompositionText(incorrectText);
    
    if (normalizedIncorrected) {
        const prediction = this.predictFromComposition(normalizedIncorrect);
        if (prediction) {
            return {
                type: 'suggestion',
                nextKey: prediction,
                source: 'ime-incorrect'
            };
        }
    }
}
```

#### 3. テストケース
- 入力状態：「いｔ」（「い」は確定、「ｔ」は全角でincorrect）
- 期待される動作：`normalizeCompositionText("ｔ")` → `"t"`
- パターンマッチング：`["tsu", "tu"]`に対して`"t"`で開始するものを検索
- 結果：`"tsu"`の次の文字`"s"`を返す

### 実装状況
- ✅ `normalizeCompositionText`関数の実装
- ✅ IME変換中の`.incorrect`要素解析の追加
- 🔄 テスト実行中

---
- リアルタイム同期の頻度調整
- 大量テキストでの処理最適化

### 2. エッジケース
- 特殊文字（記号、数字）の処理
- ユーザー定義パターンの拡張性

### 3. ユーザビリティ
- ヒント表示タイミングの最適化
- 視覚的フィードバックの改善

## 新たなアプローチ案（DOM解析+2次元配列）

### 背景
2次元配列化により、従来の「漢字からローマ字は無理」という制約が解決された。
DOMから直接文字インデックスを取得し、対応するヒントパターンを特定できる。

### アプローチ概要
```javascript
// DOM状態の例（正確な構造）
// <span class="correct">ご</span><span class="correct">連</span>
// <span class="untyped">絡</span><span class="untyped">い</span><span class="untyped">ただき</span>...

// untyped先頭文字の直接取得
const untypedFirstChar = document.querySelector('.untyped')?.textContent.charAt(0);
// -> "絡" が次の入力対象

// 文字インデックスの算出
const gameLineElement = document.querySelector('.game-line.current');
const allSpans = Array.from(gameLineElement.querySelectorAll('span'));
let charIndex = 0;
for (const span of allSpans) {
    if (span.classList.contains('untyped')) break;
    charIndex += span.textContent.length;
}
// charIndex = 2 ("ご"(0) + "連"(1) + "絡"(2))

// hints配列から対応パターンを直接取得
const targetPattern = hints[questionId].patterns[lineIndex][charIndex];
// -> [["ra"], ["ku"]] が直接取得可能
```

### 実装戦略
1. **DOM文字位置の特定**
   ```javascript
   // 正確なDOM構造に基づく位置算出
   const gameLineElement = document.querySelector('.game-line.current');
   const allSpans = Array.from(gameLineElement.querySelectorAll('span'));
   
   let currentCharIndex = 0;
   for (const span of allSpans) {
       if (span.classList.contains('untyped')) {
           break; // untypedに到達したらそこがインデックス
       }
       currentCharIndex += span.textContent.length;
   }
   // currentCharIndex = 次に入力すべき文字のインデックス
   ```

2. **2次元配列による直接参照**
   ```javascript
   // 従来：複雑な状態復元が必要
   // 新案：インデックス直接参照
   const currentHint = hints[questionId].patterns[lineIndex][currentCharIndex];
   ```

3. **ひらがな進行状況の管理**
   ```javascript
   // 現在の文字内でのローマ字進行状況
   // history長と照合してひらがな単位パターンを選択
   const hiraganaIndex = calculateHiraganaProgress(history, currentHint);
   const activePattern = currentHint[hiraganaIndex];
   ```

### 利点
- **シンプルな状態管理**: DOM状態が真の状態源
- **直接的なマッピング**: 文字インデックス→ヒントパターン
- **リアルタイム同期不要**: DOM変更に自動追従
- **履歴復元の簡素化**: 複雑な状態復元ロジック不要

### 実装例
```javascript
function getSuggestionFromDOM() {
    // DOM状態の取得（正確な構造）
    const gameLineElement = document.querySelector('.game-line.current');
    if (!gameLineElement) return null;
    
    // 各状態の文字を収集
    const correctChars = Array.from(gameLineElement.querySelectorAll('.correct'))
        .map(el => el.textContent).join('');
    const incorrectChars = Array.from(gameLineElement.querySelectorAll('.incorrect'))
        .map(el => el.textContent).join('');
    const untypedChars = Array.from(gameLineElement.querySelectorAll('.untyped'))
        .map(el => el.textContent).join('');
    
    // 現在位置の特定
    const currentCharIndex = correctChars.length; // correct文字数 = 次に入力すべき文字のインデックス
    const nextChar = untypedChars.charAt(0); // 次に入力すべき文字
    
    console.log(`Current position: ${currentCharIndex}, Next char: "${nextChar}"`);
    
    // ヒントパターンの直接取得
    const linePatterns = hints[currentQuestion.id].patterns[currentLineIndex];
    const targetPattern = linePatterns[currentCharIndex];
    
    if (!targetPattern) return null;
    
    // incorrect文字がある場合の処理
    if (incorrectChars.length > 0) {
        // エラー状態：修正が必要
        return { 
            type: 'error', 
            message: 'バックスペースで修正してください',
            incorrectCount: incorrectChars.length 
        };
    }
    
    // ひらがな進行に基づくパターン選択
    const hiraganaIndex = calculateHiraganaIndex(keyHistory, targetPattern);
    const activePattern = targetPattern[hiraganaIndex];
    
    return { 
        type: 'suggestion', 
        patterns: activePattern,
        targetChar: nextChar,
        charIndex: currentCharIndex 
    };
}

function calculateHiraganaIndex(keyHistory, targetPattern) {
    // 現在の入力履歴長から、どのひらがな単位にいるかを計算
    let accumulatedLength = 0;
    
    for (let i = 0; i < targetPattern.length; i++) {
        const hiraganaPatterns = targetPattern[i];
        if (Array.isArray(hiraganaPatterns) && hiraganaPatterns.length > 0) {
            const patternLength = hiraganaPatterns[0].length; // 最初のパターンの長さを基準
            
            if (accumulatedLength + patternLength > keyHistory.length) {
                return i; // このひらがな単位を使用
            }
            accumulatedLength += patternLength;
        }
    }
    
    return 0; // デフォルトは最初のひらがな単位
}
```

### DOM状態解析の詳細
```javascript
// 実際のDOM例（重要な発見）:
// 入力: "いつもおせわにな"
// <span class="correct">い</span><span class="correct">つ</span><span class="correct">も</span><span class="correct">お</span>
// <span class="incorrect">せ</span><span class="incorrect">わ</span>  ← IME変換前に判定済み
// <span class="correct">に</span>
// <span class="untyped">な</span><span class="untyped">っ</span><span class="untyped">て</span>...

// ★重要な発見★: untypedの先頭 = 次に入力すべき文字
const nextTargetChar = document.querySelector('.untyped')?.textContent || '';
// -> "な" が次の入力対象

const analysis = {
    correct: "いつもお" + "に",  // 正しく入力済み (5文字)
    incorrect: "せわ",           // 間違って入力 (2文字) - IME変換前に判定
    untyped: "なっており..."     // 未入力部分（先頭が次のターゲット）
};

// 文字インデックス計算
// 全体文字列での位置 = correct.length + incorrect.length + correct.length
// しかし、hintsでの論理位置 = correct文字の実際の位置
// この例では "な" は論理的に6番目の文字（い,つ,も,お,せ,わ,に,な）
// でも incorrect があるので、untyped先頭から直接特定する方が確実
```

### 簡潔なアプローチ
```javascript
function getSimpleSuggestionFromDOM() {
    // 最もシンプルな方法：untypedの先頭文字を直接取得
    const untypedElement = document.querySelector('.untyped');
    if (!untypedElement) return null;
    
    const nextChar = untypedElement.textContent.charAt(0);
    if (!nextChar) return null;
    
    // 全体の文字列を再構築してインデックスを特定
    const gameLineElement = document.querySelector('.game-line.current');
    const allSpans = Array.from(gameLineElement.querySelectorAll('span'));
    
    let charIndex = 0;
    for (const span of allSpans) {
        if (span.classList.contains('untyped')) {
            break; // untypedに到達したらそこがインデックス
        }
        charIndex += span.textContent.length;
    }
    
    console.log(`Next char: "${nextChar}", Index: ${charIndex}`);
    
    // ヒントパターンの直接取得
    const linePatterns = hints[currentQuestion.id].patterns[currentLineIndex];
    const targetPattern = linePatterns[charIndex];
    
    return {
        nextChar: nextChar,
        charIndex: charIndex,
        hintPattern: targetPattern
    };
}
```

### キーポイント
1. **untypedの先頭 = 確実な次のターゲット**: incorrectがあっても関係なし
2. **IME変換前判定**: incorrect状態は即座に確定するため、混乱なし  
3. **シンプルな特定法**: DOM順序を利用した確実なインデックス算出

### 実装統合ポイント

**DOM更新タイミングの特定**: 
```javascript
// game.js の window.handleTyping() 関数内で実装済み
// Line 430-453: span要素のclass更新処理
for (let i = 0; i < currentLine.length; i++) {
    if (i < typedText.length) {
        if (typedText[i] === currentLine[i]) {
            if (spans[i].className !== 'correct') spans[i].className = 'correct';
        } else {
            if (spans[i].className !== 'incorrect') spans[i].className = 'incorrect';
        }
    } else {
        if (spans[i].className !== 'untyped') spans[i].className = 'untyped';
    }
}

// Line 493-505: サジェスト処理の実行
if (window.gameKeyboard && keyHistoryManager) {
    const suggestedKey = keyHistoryManager.getNextSuggestedKey();
    if (suggestedKey) {
        window.gameKeyboard.showNextKeySuggestion(suggestedKey);
    } else {
        window.gameKeyboard.clearNextKeySuggestion();
    }
}
```

**統合戦略**: 
- DOM更新（correct/incorrect/untyped）後に即座にサジェスト処理実行
- `keyHistoryManager.getNextSuggestedKey()`の内部でDOM解析アプローチを採用
- リアルタイム同期の複雑さを回避し、DOM状態ベースのシンプルな実装
    return targetPattern[hiraganaIndex];
}
```

### 課題と考慮点
1. **DOM更新タイミング**: タイピング更新とサジェスト更新の同期
2. **マルチバイト文字**: 漢字1文字=配列1要素の対応関係維持
3. **プレースホルダー**: `{{user_name}}`等の特殊要素処理

### 従来手法との比較
| 観点 | 従来（状態復元） | 新案（DOM解析） |
|------|------------------|-----------------|
| 複雑度 | 高（履歴再構築） | 低（直接参照） |
| 精度 | 推定ベース | DOM状態ベース |
| パフォーマンス | 重（解析処理） | 軽（インデックス参照） |
| 保守性 | 低（状態管理） | 高（シンプル構造） |

この新アプローチにより、2次元配列の恩恵を最大限活用した、よりシンプルで確実なサジェスト機能の実現が期待される。

## 結論

当初の「漢字からローマ字は無理」という認識を、「漢字→ひらがな→ローマ字」の2段階マッピングで解決。

キーとなった気づき：
1. **表示単位≠入力単位** の理解
2. **リアルタイム状態解析** の採用
3. **2次元データ構造** による柔軟性確保

## IME変換時の特殊仕様（2025/07/26 追記）

### 問題ケース

```text
入力例: 「いつもお世話になっております。」

1. ユーザーが "いつもおせわに" と入力（未変換状態）
   - 画面表示: "いつもおせわに" (incorrect状態)
   - 実際状態: IME変換バッファ内での一時的な表示

2. ユーザーがスペースキーで変換実行
   - 画面表示: "いつもお世話に" (correct状態)  
   - 実際状態: 正しい漢字に変換完了
```

### 解決方針

**IME変換中（未確定状態）では`incorrect`要素のチェックを無視する**

#### 理由

- 「せわ」→「世話」のような漢字変換過程では、一時的にincorrect状態となる
- この状態は技術的な制約によるものであり、ユーザーのタイピングスキルとは無関係
- **タイピングとしては正しい入力**のため、エラー扱いすべきではない

#### 実装

```javascript
// IME変換中でない場合のみincorrect要素をチェック
if (typeof window.isComposingText === 'undefined' || !window.isComposingText) {
    const incorrectElements = gameLineElement.querySelectorAll('.incorrect');
    if (incorrectElements.length > 0) {
        return {
            type: 'error',
            message: 'バックスペースで修正してください',
            incorrectCount: incorrectElements.length
        };
    }
} else {
    console.log('IME composition in progress, skipping incorrect check');
}
```

この修正により、IME変換プロセス中でも適切なローマ字サジェストが継続表示される。

